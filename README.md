# Лабораторна №3: Splay Tree.

Дерево выкористовується найчастіше для кешування (елементи котрі додавались/шукались/у яких діти видялялись востаннє знаходяться ближче до корня дерева)
Не збалансоване. Баланс ну трохи підритмується тільки під час поворотів у функції `_Splay`.

В моїй реалізація кожна вершина має вказівник на батка.
### Основні функції:
-----------
1. __add__ - O(log n + log n) ~= *O(log n)*

  Додає елемент до низу дерева (O(log n)) як у стандартному бінарному дереві, потім за допомогою поворотів (O(1)) виводить елемент на вершину (O(log n)) за доп функції `_Splay`
  
2. __find__ - O(log n + log n) ~= *O(log n)*

  Шукає елемент порівнюючи його з данний як у стандартному бінарному дереві (O(log n)) + потім `_Splay` цього елементу
  
3. __delete__ - O(log n + log n) ~= *O(log n)*

  Теж як у стандартному бінарному дереві, але в кінці до батька видяляємого елемента застосовує функцію `_Splay`
  
4. **Splay** - O(log n)

  Вираховує в залежності від положення елементу яку операцію повороту застосувати ([zig/zigZig/zigZag](https://en.wikipedia.org/wiki/Splay_tree#Splaying))
і послідовно виконує їх поки елемент стане в корінь
